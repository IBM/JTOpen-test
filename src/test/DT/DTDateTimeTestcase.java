///////////////////////////////////////////////////////////////////////////////
//
// JTOpen (IBM Toolbox for Java - OSS version)
//
// Filename:  DTDateTimeTestcase.java
//
// The source code contained herein is licensed under the IBM Public License
// Version 1.0, which has been approved by the Open Source Initiative.
// Copyright (C) 1997-2023 International Business Machines Corporation and
// others.  All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////

package test.DT;

import com.ibm.as400.access.AS400;
import com.ibm.as400.access.AS400AbstractTime;
import com.ibm.as400.access.AS400Date;
import com.ibm.as400.access.AS400Time;
import com.ibm.as400.access.AS400Timestamp;
import com.ibm.as400.access.ExtendedIllegalArgumentException;

import test.Testcase;

import java.sql.Time;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.TimeZone;
import java.util.Locale;
import java.util.Calendar;
import java.util.GregorianCalendar;

/**
 Testcase DTDateTimeTestcase.
 **/
public class DTDateTimeTestcase extends Testcase
{
  public static void main(String args[]) throws Exception {
    String[] newArgs = new String[args.length+2];
     newArgs[0] = "-tc";
     newArgs[1] = "DTDateTimeTestcase";
     for (int i = 0; i < args.length; i++) {
       newArgs[2+i]=args[i];
     }
     test.DTTest.main(newArgs); 
   }

  static final boolean DEBUG = false;

  static final int AS400DATE_FORMAT_MIN = AS400Date.FORMAT_MDY;
  static final int AS400DATE_FORMAT_MAX = AS400Date.FORMAT_YYM;

  static final int AS400TIME_FORMAT_MIN = AS400Time.FORMAT_HMS;
  static final int AS400TIME_FORMAT_MAX = AS400Time.FORMAT_JIS;

  static final TimeZone TIMEZONE_LOCAL = TimeZone.getDefault();
  static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone("GMT-0");
  static final Calendar CALENDAR_LOCAL = Calendar.getInstance(TIMEZONE_LOCAL);
  static final GregorianCalendar CALENDAR_GMT = new GregorianCalendar(TIMEZONE_GMT, Locale.US);
  static final SimpleDateFormat FORMATTER_LOCAL = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS z");
  static final SimpleDateFormat FORMATTER_GMT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS z");
  static {
    FORMATTER_GMT.setTimeZone(TIMEZONE_GMT);
  }
  //static final SimpleDateFormat FORMATTER_HMS = new SimpleDateFormat("HH:mm:ss");
  //static {
  //  FORMATTER_HMS.setTimeZone(TIMEZONE_GMT);
  //}


  static final long MILLISECONDS_PER_SECOND = 1000L;
  static final long MILLISECONDS_PER_MINUTE = 60 * MILLISECONDS_PER_SECOND;
  static final long MINUTES_PER_DAY = 1440L;

  boolean verifyRoundTrip(AS400AbstractTime converter, java.util.Date valueIn, StringBuffer sb)
  {
    boolean matched = true;

    String valInString = toGMTString(valueIn);
    sb.append("Value in:            " + valInString+"\n");

    byte[] bytesOut = converter.toBytes(valueIn);
    sb.append("Generated byte array for " + valInString + ":");
    dumpByteArray(sb, bytesOut);
    sb.append("\n");

    java.util.Date valueOut = (java.util.Date)converter.toObject(bytesOut);

    String valOutString = toGMTString(valueOut);
    sb.append("Round-tripped value: " + valOutString+"\n");

    if (converter instanceof AS400Timestamp)
    {
      // Precision of java.sql.Timestamp is nanosecs, but AS400Timestamp is microseconds.
      long millisIn = valueIn.getTime();
      long millisOut = valueOut.getTime();
      int nanosIn = ((Timestamp)valueIn).getNanos();
      int nanosOut = ((Timestamp)valueOut).getNanos();
      matched = (millisIn == millisOut &&
                 nanosIn/1000 == nanosOut/1000);
    }

    else if (converter instanceof AS400Time)
    {
      // Different precision, so round down, depending on format.
      long val = valueIn.getTime();
      long truncatedVal;
      if (((AS400Time)converter).getFormat() == AS400Time.FORMAT_USA) {
        // Round down to nearest minute.  (1 minute == 60000 milliseconds)
        truncatedVal = val - (val % MILLISECONDS_PER_MINUTE);
      }
      else {
        // Round down to nearest second.  (1 second == 1000 milliseconds)
        truncatedVal = val - (val % MILLISECONDS_PER_SECOND);
      }
      matched = (valueOut.equals(new java.sql.Time(truncatedVal)));
    }


    else if (converter instanceof AS400Date)
    {
      // Round down to nearest day.  (1 minute == 60000 milliseconds)
      // Note: For dates prior to 1970, Date.getTime() returns a negative value.
      java.sql.Date truncatedDate = truncateHours((java.sql.Date)valueIn);

      matched = (valueOut.equals(truncatedDate));
    }

    if (!matched) {
      sb.append("verifyRoundTrip(): Generated object doesn't match supplied object.\n");
    }

    return matched;
  }


  static java.sql.Date truncateHours(java.sql.Date dateObj)
  {
    CALENDAR_GMT.setTimeInMillis(dateObj.getTime());
    CALENDAR_GMT.set(Calendar.HOUR_OF_DAY, 0);
    CALENDAR_GMT.set(Calendar.MINUTE, 0);
    CALENDAR_GMT.set(Calendar.SECOND, 0);
    CALENDAR_GMT.set(Calendar.MILLISECOND, 0);

    return new java.sql.Date(CALENDAR_GMT.getTimeInMillis());
  }

  static String toGMTString(java.util.Date dateObj)
  {
    String outString = FORMATTER_GMT.format(dateObj);
    if (dateObj instanceof java.sql.Timestamp) {
      int nanos = ((java.sql.Timestamp)dateObj).getNanos();
      outString = outString + " (nanoseconds: " + nanos + ")";
    }
    return outString;
  }


  static java.sql.Date toSQLDate(int year, int month, int day)
  {
    CALENDAR_GMT.set(year,month-1,day);  // 'Calendar' uses 0-based numbering
    return new java.sql.Date(CALENDAR_GMT.getTimeInMillis());
  }

  static long toMillis(int hh, int mm, int ss)
  {
    long seconds = ss + 60*mm + 60*60*hh;
    return 1000*seconds;
  }


  /**
   Test: Verify that the correct values are returned by getDefaultValue().
   Result: The correct values are returned.
   **/
  public void Var001()
  {
    boolean succeeded = true;
    try
    {
      Object obj;

      obj = new AS400Date().getDefaultValue();
      if (!(obj instanceof java.sql.Date) || !obj.equals(new java.sql.Date(0L))) {
        System.out.println("Wrong default for AS400Date.");
        succeeded = false;
      }

      obj = new AS400Time().getDefaultValue();
      if (!(obj instanceof java.sql.Time) || !obj.equals(new java.sql.Time(0L))) {
        System.out.println("Wrong default for AS400Time.");
        succeeded = false;
      }

      obj = new AS400Timestamp().getDefaultValue();
      if (!(obj instanceof java.sql.Timestamp) || !obj.equals(new java.sql.Timestamp(0L))) {
        System.out.println("Wrong default for AS400Timestamp.");
        succeeded = false;
      }

      assertCondition(succeeded);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: Verify that values sent and retrieved via AS400Date, match.
   Result: AS400Date values successfully round-trip.
   **/
  public void Var002()
  {
      StringBuffer sb = new StringBuffer(); 
    boolean succeeded = true;
    try
    {
      AS400Date converter = new AS400Date();

      int[] formats = {
        AS400Date.FORMAT_MDY,
        AS400Date.FORMAT_DMY,
        AS400Date.FORMAT_YMD,
        AS400Date.FORMAT_JUL,
        AS400Date.FORMAT_ISO,
        AS400Date.FORMAT_USA,
        AS400Date.FORMAT_EUR,
        AS400Date.FORMAT_JIS,
        AS400Date.FORMAT_CYMD,
        AS400Date.FORMAT_CMDY,
        AS400Date.FORMAT_CDMY,
        AS400Date.FORMAT_LONGJUL };

        int[] lengths = {
          8,   // AS400Date.FORMAT_MDY,
          8,   // AS400Date.FORMAT_DMY,
          8,   // AS400Date.FORMAT_YMD,
          6,   // AS400Date.FORMAT_JUL,
          10,  // AS400Date.FORMAT_ISO,
          10,  // AS400Date.FORMAT_USA,
          10,  // AS400Date.FORMAT_EUR,
          10,  // AS400Date.FORMAT_JIS,
          9,   // AS400Date.FORMAT_CYMD,
          9,   // AS400Date.FORMAT_CMDY,
          9,   // AS400Date.FORMAT_CDMY,
          8};  // AS400Date.FORMAT_LONGJUL 

          CALENDAR_LOCAL.setTimeInMillis(new java.util.Date().getTime());  // now
          java.util.Date now = CALENDAR_LOCAL.getTime();
          long nowMillis = now.getTime();
          java.sql.Date[] values = {
            toSQLDate(1940, 1,  1),
            toSQLDate(2039, 1,  1),
            new java.sql.Date(nowMillis)
          };
          boolean matched;

          for (int ff = 0; ff < formats.length; ff++)
          {
            converter.setFormat(formats[ff]);
            if (converter.getByteLength() != lengths[ff]) {
              System.out.println("Incorrect length for AS400Date format " + ff);
              succeeded = false;
            }
            for (int vv = 0; vv < values.length; vv++)
            {
              java.sql.Date day = values[vv];
              sb.append("\n");
              sb.append(">>> java.sql.Date == " + toGMTString(day)+"\n");
              matched = verifyRoundTrip(converter, day, sb);
              if (!matched) succeeded = false;
            }
          }
          assertCondition(succeeded);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: Verify that values sent and retrieved via AS400Time, match.
   Result: AS400Time values successfully round-trip.
   **/
  public void Var003()
  {
    StringBuffer sb = new StringBuffer(); 
    boolean succeeded = true;
    try
    {
      AS400Time converter = new AS400Time();

      int[] formats = {
        AS400Time.FORMAT_HMS,
        AS400Time.FORMAT_USA,
        AS400Time.FORMAT_EUR,
        AS400Time.FORMAT_JIS };

        int[] lengths = {
          8,   // AS400Time.FORMAT_HMS,
          8,   // AS400Time.FORMAT_USA,
          8,   // AS400Time.FORMAT_EUR,
          8 }; // AS400Time.FORMAT_JIS

          int[] values = { 0, 1, 3600, 86399 };  // seconds
          boolean matched;

          for (int ff = 0; ff < formats.length; ff++)
          {
            converter.setFormat(formats[ff]);
            if (converter.getByteLength() != lengths[ff]) {
              System.out.println("Incorrect length for AS400Time format " + ff);
              succeeded = false;
            }
            for (int vv = 0; vv < values.length; vv++)
            {
              int milliseconds = 1000*values[vv];  // convert seconds to millis
              sb.append("\n");
              sb.append(">>> new java.sql.Time("+milliseconds+")\n");
              java.sql.Time time = new java.sql.Time(milliseconds);
              sb.append(">>> java.sql.Time == " + toGMTString(time)+"\n");
              matched = verifyRoundTrip(converter, new java.sql.Time(milliseconds), sb);
              if (!matched) succeeded = false;
            }
          }
          assertCondition(succeeded, sb.toString());
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: Verify that values sent and retrieved via AS400Timestamp, match.
   Result: AS400Timestamp values successfully round-trip.
   **/
  public void Var004()
  {
      StringBuffer sb = new StringBuffer(); 
    boolean succeeded = true;
    try
    {
      AS400Timestamp converter = new AS400Timestamp();
      if (converter.getByteLength() != 26) {
        System.out.println("Incorrect length for AS400TimeStamp: " + converter.getByteLength());
        succeeded = false;
      }

      // AS400Timestamp has only one format available.

      CALENDAR_LOCAL.setTimeInMillis(new java.util.Date().getTime());  // now
      java.util.Date now = CALENDAR_LOCAL.getTime();
      long[] values = { 0, 1, 3600, 86399, now.getTime() };  // milliseconds since Jan 1 1970
      boolean matched;
      int nanos = 0;
      for (int vv = 0; vv < values.length; vv++)
      {
        java.sql.Timestamp tstamp = new java.sql.Timestamp(values[vv]);
        tstamp.setNanos(nanos);
        sb.append("\n");
        sb.append(">>> java.sql.Timestamp == " + toGMTString(tstamp)+"\n");
        matched = verifyRoundTrip(converter, tstamp, sb);
        if (!matched) succeeded = false;
        nanos += 1000;
      }
      assertCondition(succeeded);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: Construct an AS400Date(int format) object with an invalid format.
   Result: ExtendedIllegalArgumentException should be thrown.
   **/
  public void Var005()
  {
    try
    {
      AS400Date converter = new AS400Date(99);
      failed("No exception thrown.");
    }
    catch (Exception e)
    {
      assertExceptionStartsWith(e, "ExtendedIllegalArgumentException", "format (99): ", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);
    }
  }


  /**
   Test: Construct an AS400Time(int format) object with an invalid format.
   Result: ExtendedIllegalArgumentException should be thrown.
   **/
  public void Var006()
  {
    try
    {
      AS400Time converter = new AS400Time(0);
      failed("No exception thrown.");
    }
    catch (Exception e)
    {
      assertExceptionStartsWith(e, "ExtendedIllegalArgumentException", "format (0): ", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);
    }
  }


  /**
   Test: AS400Date: For each format, verify that toBytes() followed by toObject(), round-trips to the original value.
   Result: AS400Date values successfully round-trip.
   **/
  public void Var007()
  {
    boolean ok = true;
    try
    {
      final int minFormat = AS400DATE_FORMAT_MIN;
      final int maxFormat = AS400DATE_FORMAT_MAX;
      java.sql.Date defaultVal = (java.sql.Date)new AS400Date().getDefaultValue();
      for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      {
        AS400Date conv = new AS400Date(fmt);
        byte[] bytes = conv.toBytes(defaultVal);
        Object newObj = conv.toObject(bytes);
        if (!(newObj instanceof java.sql.Date) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      }
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: AS400Time: For each format, verify that toBytes() followed by toObject(), round-trips to the original value.
   Result: AS400Time values successfully round-trip.
   **/
  public void Var008()
  {
    boolean ok = true;
    try
    {
      final int minFormat = AS400TIME_FORMAT_MIN;
      final int maxFormat = AS400TIME_FORMAT_MAX;
      java.sql.Time defaultVal = (java.sql.Time)new AS400Time().getDefaultValue();
      for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      {
        AS400Time conv = new AS400Time(fmt);
        byte[] bytes = conv.toBytes(defaultVal);
        Object newObj = conv.toObject(bytes);
        if (!(newObj instanceof java.sql.Time) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      }
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: AS400Timestamp: For each format, verify that toBytes() followed by toObject(), round-trips to the original value.
   Result: AS400Timestamp values successfully round-trip.
   **/
  public void Var009()
  {
    boolean ok = true;
    try
    {
      //final int minFormat = AS400Timestamp.FORMAT_xxx;
      //final int maxFormat = AS400Timestamp.FORMAT_xxx;
      java.sql.Timestamp defaultVal = (java.sql.Timestamp)new AS400Timestamp().getDefaultValue();
      //for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      //{
        //AS400Timestamp conv = new AS400Timestamp(fmt);
        AS400Timestamp conv = new AS400Timestamp();
        byte[] bytes = conv.toBytes(defaultVal);
        Object newObj = conv.toObject(bytes);
        if (!(newObj instanceof java.sql.Timestamp) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          //System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("Timestamp object failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      //}
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: AS400Date: For each format, verify that toXsdString() followed by parseXsdString(), round-trips to the original value.
   Result: AS400Date values successfully round-trip.
   **/
  public void Var010()
  {
    boolean ok = true;
    try
    {
      final int minFormat = AS400DATE_FORMAT_MIN;
      final int maxFormat = AS400DATE_FORMAT_MAX;
      java.sql.Date defaultVal = (java.sql.Date)new AS400Date().getDefaultValue();
      for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      {
        AS400Date conv = new AS400Date(fmt);
        String string = conv.toXsdString(defaultVal);
        Object newObj = conv.parseXsdString(string);
        if (!(newObj instanceof java.sql.Date) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      }
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: AS400Time: For each format, verify that toXsdString() followed by parseXsdString(), round-trips to the original value.
   Result: AS400Time values successfully round-trip.
   **/
  public void Var011()
  {
    boolean ok = true;
    try
    {
      final int minFormat = AS400TIME_FORMAT_MIN;
      final int maxFormat = AS400TIME_FORMAT_MAX;
      java.sql.Time defaultVal = (java.sql.Time)new AS400Time().getDefaultValue();
      for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      {
        AS400Time conv = new AS400Time(fmt);
        String string = conv.toXsdString(defaultVal);
        Object newObj = conv.parseXsdString(string);
        if (!(newObj instanceof java.sql.Time) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      }
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


  /**
   Test: AS400Timestamp: For each format, verify that toXsdString() followed by parseXsdString(), round-trips to the original value.
   Result: AS400Timestamp values successfully round-trip.
   **/
  public void Var012()
  {
    boolean ok = true;
    try
    {
      //final int minFormat = AS400Timestamp.FORMAT_xxx;
      //final int maxFormat = AS400Timestamp.FORMAT_xxx;
      java.sql.Timestamp defaultVal = (java.sql.Timestamp)new AS400Timestamp().getDefaultValue();
      //for (int fmt=minFormat; fmt<= maxFormat; fmt++)
      //{
        //AS400Timestamp conv = new AS400Timestamp(fmt);
        AS400Timestamp conv = new AS400Timestamp();
        String string = conv.toXsdString(defaultVal);
        Object newObj = conv.parseXsdString(string);
        if (!(newObj instanceof java.sql.Timestamp) ||
             !defaultVal.equals(newObj))
        {
          ok = false;
          //System.out.println("Format " + fmt + " failed to round-trip correctly.");
          System.out.println("Timestamp object failed to round-trip correctly.");
          System.out.println("newObj is of type " + newObj.getClass().getName());
        }
      //}
      assertCondition(ok);
    }
    catch (Exception e)
    {
      failed(e, "Unexpected exception.");
    }
  }


}



